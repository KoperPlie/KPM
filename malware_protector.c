/*
 * MalwareProtector KPM - Android恶意脚本防护模块
 * 
 * 功能:
 * - 拦截危险的dd命令执行
 * - 保护敏感分区不被擦除
 * - 提供用户确认机制
 * - 记录安全事件日志
 * 
 * 兼容: KernelSU/APatch KPM框架
 * 作者: AI Assistant
 * 版本: 1.0
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/syscalls.h>
#include <linux/string.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/atomic.h>
#include <linux/time.h>
#include <linux/delay.h>
#include <linux/input.h>
#include <linux/notifier.h>
#include <linux/workqueue.h>
#include <linux/mutex.h>

// KernelPatch相关头文件 (需要根据实际KPM框架调整)
#include "kputils.h"
#include "kpmodule.h"

#define MODULE_NAME "malware_protector"
#define MODULE_VERSION "1.0"
#define MAX_PATH_LEN 256
#define MAX_CMD_LEN 512
#define USER_CONFIRM_TIMEOUT 5  // 5秒超时

// 模块信息
MODULE_LICENSE("GPL");
MODULE_AUTHOR("AI Assistant");
MODULE_DESCRIPTION("Android Malware Protection KPM Module");
MODULE_VERSION(MODULE_VERSION);

// 敏感分区列表
static const char *sensitive_partitions[] = {
    "persist", "vm-persist",
    "modem_a", "modem_b", "modemst1", "modemst2",
    "fsg", "fsc",
    "abl_a", "abl_b",
    "featenabler_a", "featenabler_b",
    "xbl_a", "xbl_b", "xbl_config_a", "xbl_config_b",
    "xbl_ramdump_a", "xbl_ramdump_b",
    "xbl_sc_logs", "xbl_sc_test_mode",
    "vendor_boot_a", "vendor_boot_b",
    "ocdt",
    NULL
};

// 保护动作枚举
enum protection_action {
    ACTION_ALLOW,           // 允许执行
    ACTION_DENY_AUTO,       // 自动拒绝
    ACTION_REQUIRE_CONFIRM, // 需要用户确认
    ACTION_LOG_ONLY         // 仅记录日志
};

// dd命令检测结构
struct dd_detection {
    bool is_dd_command;
    char input_file[MAX_PATH_LEN];
    char output_file[MAX_PATH_LEN];
    bool is_zero_source;
    bool is_block_target;
};

// 用户输入结构
struct user_input {
    atomic_t volume_up_pressed;
    atomic_t volume_down_pressed;
    unsigned long timestamp;
    bool timeout_reached;
    struct completion input_completion;
};

// 安全事件结构
struct security_event {
    unsigned long timestamp;
    pid_t pid;
    uid_t uid;
    char comm[TASK_COMM_LEN];
    char operation[64];
    char target_device[MAX_PATH_LEN];
    enum protection_action action_taken;
    bool user_confirmed;
};

// 统计信息结构
struct protection_stats {
    atomic_t total_operations;
    atomic_t blocked_operations;
    atomic_t user_confirmed;
    atomic_t auto_denied;
    atomic_t sensitive_partition_access;
};

// 全局变量
static struct protection_stats stats;
static struct user_input user_input_state;
static struct mutex protection_mutex;
static bool protection_enabled = true;
static struct proc_dir_entry *proc_dir;

// 原始系统调用指针
static long (*orig_sys_write)(unsigned int fd, const char __user *buf, size_t count);
static long (*orig_sys_openat)(int dfd, const char __user *filename, int flags, umode_t mode);
static long (*orig_sys_execve)(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);

// 函数声明
static bool is_sensitive_partition(const char *device_path);
static bool detect_dd_command(const char __user *filename, const char __user *const __user *argv, struct dd_detection *result);
static enum protection_action evaluate_operation(const char *device_path, struct dd_detection *dd_info);
static bool wait_for_user_confirmation(int timeout_seconds);
static void log_security_event(const char *message, struct security_event *event);

/**
 * 检查是否为敏感分区
 */
static bool is_sensitive_partition(const char *device_path)
{
    int i;
    char *partition_name;
    
    if (!device_path)
        return false;
    
    // 提取分区名称
    partition_name = strrchr(device_path, '/');
    if (partition_name)
        partition_name++;
    else
        partition_name = (char *)device_path;
    
    // 检查是否在敏感分区列表中
    for (i = 0; sensitive_partitions[i]; i++) {
        if (strstr(partition_name, sensitive_partitions[i])) {
            return true;
        }
    }
    
    return false;
}

/**
 * 检测dd命令
 */
static bool detect_dd_command(const char __user *filename, const char __user *const __user *argv, struct dd_detection *result)
{
    char *kernel_filename = NULL;
    char **kernel_argv = NULL;
    int argc = 0, i;
    bool ret = false;
    
    if (!filename || !argv || !result)
        return false;
    
    memset(result, 0, sizeof(*result));
    
    // 复制文件名到内核空间
    kernel_filename = kmalloc(MAX_PATH_LEN, GFP_KERNEL);
    if (!kernel_filename)
        return false;
    
    if (strncpy_from_user(kernel_filename, filename, MAX_PATH_LEN - 1) < 0)
        goto cleanup;
    
    kernel_filename[MAX_PATH_LEN - 1] = '\0';
    
    // 检查是否为dd命令
    if (!strstr(kernel_filename, "dd") && !strstr(kernel_filename, "/dd"))
        goto cleanup;
    
    result->is_dd_command = true;
    
    // 计算参数数量
    while (argc < 32) {  // 限制最大参数数量
        const char __user *arg;
        if (get_user(arg, argv + argc) || !arg)
            break;
        argc++;
    }
    
    if (argc == 0)
        goto cleanup;
    
    // 分配内核参数数组
    kernel_argv = kmalloc(sizeof(char*) * argc, GFP_KERNEL);
    if (!kernel_argv)
        goto cleanup;
    
    // 复制参数到内核空间
    for (i = 0; i < argc; i++) {
        const char __user *user_arg;
        if (get_user(user_arg, argv + i) || !user_arg)
            break;
        
        kernel_argv[i] = kmalloc(MAX_CMD_LEN, GFP_KERNEL);
        if (!kernel_argv[i])
            break;
        
        if (strncpy_from_user(kernel_argv[i], user_arg, MAX_CMD_LEN - 1) < 0) {
            kfree(kernel_argv[i]);
            break;
        }
        kernel_argv[i][MAX_CMD_LEN - 1] = '\0';
    }
    
    // 解析dd参数
    for (i = 0; i < argc; i++) {
        if (!kernel_argv[i])
            continue;
        
        if (strncmp(kernel_argv[i], "if=", 3) == 0) {
            strncpy(result->input_file, kernel_argv[i] + 3, MAX_PATH_LEN - 1);
            if (strstr(result->input_file, "/dev/zero"))
                result->is_zero_source = true;
        } else if (strncmp(kernel_argv[i], "of=", 3) == 0) {
            strncpy(result->output_file, kernel_argv[i] + 3, MAX_PATH_LEN - 1);
            if (strstr(result->output_file, "/dev/block/"))
                result->is_block_target = true;
        }
    }
    
    ret = true;
    
cleanup:
    if (kernel_filename)
        kfree(kernel_filename);
    
    if (kernel_argv) {
        for (i = 0; i < argc && kernel_argv[i]; i++)
            kfree(kernel_argv[i]);
        kfree(kernel_argv);
    }
    
    return ret;
}

/**
 * 评估操作风险等级
 */
static enum protection_action evaluate_operation(const char *device_path, struct dd_detection *dd_info)
{
    // 1. 检查是否为敏感分区 - 自动拒绝
    if (device_path && is_sensitive_partition(device_path)) {
        atomic_inc(&stats.sensitive_partition_access);
        return ACTION_DENY_AUTO;
    }
    
    // 2. 检查是否为dd零填充操作 - 需要确认
    if (dd_info && dd_info->is_dd_command && dd_info->is_zero_source && dd_info->is_block_target) {
        return ACTION_REQUIRE_CONFIRM;
    }
    
    // 3. 检查是否为其他块设备写操作 - 需要确认
    if (device_path && strstr(device_path, "/dev/block/")) {
        return ACTION_REQUIRE_CONFIRM;
    }
    
    return ACTION_ALLOW;
}

/**
 * 等待用户确认
 */
static bool wait_for_user_confirmation(int timeout_seconds)
{
    unsigned long timeout_jiffies;
    bool result = false;
    
    // 初始化用户输入状态
    atomic_set(&user_input_state.volume_up_pressed, 0);
    atomic_set(&user_input_state.volume_down_pressed, 0);
    user_input_state.timestamp = jiffies;
    user_input_state.timeout_reached = false;
    init_completion(&user_input_state.input_completion);
    
    // 输出提示信息到内核日志
    printk(KERN_WARNING "[%s] SECURITY ALERT: Dangerous operation detected!\n", MODULE_NAME);
    printk(KERN_WARNING "[%s] Press Volume+ to ALLOW, Volume- to DENY (timeout: %ds)\n", MODULE_NAME, timeout_seconds);
    
    timeout_jiffies = msecs_to_jiffies(timeout_seconds * 1000);
    
    // 等待用户输入或超时
    if (wait_for_completion_timeout(&user_input_state.input_completion, timeout_jiffies)) {
        // 有用户输入
        if (atomic_read(&user_input_state.volume_up_pressed)) {
            result = true;
            atomic_inc(&stats.user_confirmed);
            printk(KERN_INFO "[%s] User ALLOWED dangerous operation\n", MODULE_NAME);
        } else {
            result = false;
            printk(KERN_INFO "[%s] User DENIED dangerous operation\n", MODULE_NAME);
        }
    } else {
        // 超时
        result = false;
        user_input_state.timeout_reached = true;
        printk(KERN_INFO "[%s] User confirmation TIMEOUT - operation denied\n", MODULE_NAME);
    }
    
    return result;
}

/**
 * 记录安全事件
 */
static void log_security_event(const char *message, struct security_event *event)
{
    if (event) {
        printk(KERN_INFO "[%s] %s - PID:%d UID:%d CMD:%s TARGET:%s ACTION:%d\n",
               MODULE_NAME, message, event->pid, event->uid, event->comm,
               event->target_device, event->action_taken);
    } else {
        printk(KERN_INFO "[%s] %s\n", MODULE_NAME, message);
    }
}

/**
 * Hook的sys_write函数
 */
static long hooked_sys_write(unsigned int fd, const char __user *buf, size_t count)
{
    struct file *file;
    char *device_path = NULL;
    enum protection_action action;
    struct security_event event;
    long ret;
    
    if (!protection_enabled)
        return orig_sys_write(fd, buf, count);
    
    atomic_inc(&stats.total_operations);
    
    // 获取文件描述符对应的文件
    file = fget(fd);
    if (!file)
        return orig_sys_write(fd, buf, count);
    
    // 检查是否为块设备
    if (!S_ISBLK(file_inode(file)->i_mode)) {
        fput(file);
        return orig_sys_write(fd, buf, count);
    }
    
    // 获取设备路径
    device_path = kmalloc(MAX_PATH_LEN, GFP_KERNEL);
    if (device_path) {
        char *path = d_path(&file->f_path, device_path, MAX_PATH_LEN);
        if (IS_ERR(path)) {
            kfree(device_path);
            device_path = NULL;
        } else {
            memmove(device_path, path, strlen(path) + 1);
        }
    }
    
    fput(file);
    
    if (!device_path)
        return orig_sys_write(fd, buf, count);
    
    // 评估操作风险
    action = evaluate_operation(device_path, NULL);
    
    // 填充事件信息
    memset(&event, 0, sizeof(event));
    event.timestamp = jiffies;
    event.pid = current->pid;
    event.uid = current_uid().val;
    strncpy(event.comm, current->comm, TASK_COMM_LEN - 1);
    strncpy(event.operation, "write", sizeof(event.operation) - 1);
    strncpy(event.target_device, device_path, MAX_PATH_LEN - 1);
    event.action_taken = action;
    
    mutex_lock(&protection_mutex);
    
    switch (action) {
        case ACTION_ALLOW:
            ret = orig_sys_write(fd, buf, count);
            break;
            
        case ACTION_DENY_AUTO:
            atomic_inc(&stats.auto_denied);
            log_security_event("Auto-denied sensitive partition write", &event);
            ret = -EACCES;
            break;
            
        case ACTION_REQUIRE_CONFIRM:
            if (wait_for_user_confirmation(USER_CONFIRM_TIMEOUT)) {
                event.user_confirmed = true;
                log_security_event("User confirmed dangerous write operation", &event);
                ret = orig_sys_write(fd, buf, count);
            } else {
                atomic_inc(&stats.blocked_operations);
                event.user_confirmed = false;
                log_security_event("User denied dangerous write operation", &event);
                ret = -EACCES;
            }
            break;
            
        case ACTION_LOG_ONLY:
            log_security_event("Suspicious write operation detected", &event);
            ret = orig_sys_write(fd, buf, count);
            break;
            
        default:
            ret = orig_sys_write(fd, buf, count);
            break;
    }
    
    mutex_unlock(&protection_mutex);
    
    if (device_path)
        kfree(device_path);
    
    return ret;
}

/**
 * Hook的sys_execve函数
 */
static long hooked_sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp)
{
    struct dd_detection dd_info;
    enum protection_action action;
    struct security_event event;
    long ret;
    
    if (!protection_enabled)
        return orig_sys_execve(filename, argv, envp);
    
    // 检测dd命令
    if (!detect_dd_command(filename, argv, &dd_info) || !dd_info.is_dd_command)
        return orig_sys_execve(filename, argv, envp);
    
    atomic_inc(&stats.total_operations);
    
    // 评估dd操作风险
    action = evaluate_operation(dd_info.output_file, &dd_info);
    
    // 填充事件信息
    memset(&event, 0, sizeof(event));
    event.timestamp = jiffies;
    event.pid = current->pid;
    event.uid = current_uid().val;
    strncpy(event.comm, current->comm, TASK_COMM_LEN - 1);
    strncpy(event.operation, "dd_command", sizeof(event.operation) - 1);
    strncpy(event.target_device, dd_info.output_file, MAX_PATH_LEN - 1);
    event.action_taken = action;
    
    mutex_lock(&protection_mutex);
    
    switch (action) {
        case ACTION_ALLOW:
            ret = orig_sys_execve(filename, argv, envp);
            break;
            
        case ACTION_DENY_AUTO:
            atomic_inc(&stats.auto_denied);
            log_security_event("Auto-denied dd command on sensitive partition", &event);
            ret = -EACCES;
            break;
            
        case ACTION_REQUIRE_CONFIRM:
            if (wait_for_user_confirmation(USER_CONFIRM_TIMEOUT)) {
                event.user_confirmed = true;
                log_security_event("User confirmed dangerous dd command", &event);
                ret = orig_sys_execve(filename, argv, envp);
            } else {
                atomic_inc(&stats.blocked_operations);
                event.user_confirmed = false;
                log_security_event("User denied dangerous dd command", &event);
                ret = -EACCES;
            }
            break;
            
        case ACTION_LOG_ONLY:
            log_security_event("Suspicious dd command detected", &event);
            ret = orig_sys_execve(filename, argv, envp);
            break;
            
        default:
            ret = orig_sys_execve(filename, argv, envp);
            break;
    }
    
    mutex_unlock(&protection_mutex);
    
    return ret;
}

/**
 * Hook的sys_openat函数
 */
static long hooked_sys_openat(int dfd, const char __user *filename, int flags, umode_t mode)
{
    char *kernel_filename = NULL;
    enum protection_action action;
    struct security_event event;
    long ret;
    
    if (!protection_enabled)
        return orig_sys_openat(dfd, filename, flags, mode);
    
    // 只检查写操作
    if (!(flags & (O_WRONLY | O_RDWR)))
        return orig_sys_openat(dfd, filename, flags, mode);
    
    // 复制文件名到内核空间
    kernel_filename = kmalloc(MAX_PATH_LEN, GFP_KERNEL);
    if (!kernel_filename)
        return orig_sys_openat(dfd, filename, flags, mode);
    
    if (strncpy_from_user(kernel_filename, filename, MAX_PATH_LEN - 1) < 0) {
        kfree(kernel_filename);
        return orig_sys_openat(dfd, filename, flags, mode);
    }
    
    kernel_filename[MAX_PATH_LEN - 1] = '\0';
    
    // 只检查块设备
    if (!strstr(kernel_filename, "/dev/block/")) {
        kfree(kernel_filename);
        return orig_sys_openat(dfd, filename, flags, mode);
    }
    
    atomic_inc(&stats.total_operations);
    
    // 评估操作风险
    action = evaluate_operation(kernel_filename, NULL);
    
    // 填充事件信息
    memset(&event, 0, sizeof(event));
    event.timestamp = jiffies;
    event.pid = current->pid;
    event.uid = current_uid().val;
    strncpy(event.comm, current->comm, TASK_COMM_LEN - 1);
    strncpy(event.operation, "open_write", sizeof(event.operation) - 1);
    strncpy(event.target_device, kernel_filename, MAX_PATH_LEN - 1);
    event.action_taken = action;
    
    mutex_lock(&protection_mutex);
    
    switch (action) {
        case ACTION_ALLOW:
            ret = orig_sys_openat(dfd, filename, flags, mode);
            break;
            
        case ACTION_DENY_AUTO:
            atomic_inc(&stats.auto_denied);
            log_security_event("Auto-denied sensitive partition open", &event);
            ret = -EACCES;
            break;
            
        case ACTION_REQUIRE_CONFIRM:
            if (wait_for_user_confirmation(USER_CONFIRM_TIMEOUT)) {
                event.user_confirmed = true;
                log_security_event("User confirmed dangerous open operation", &event);
                ret = orig_sys_openat(dfd, filename, flags, mode);
            } else {
                atomic_inc(&stats.blocked_operations);
                event.user_confirmed = false;
                log_security_event("User denied dangerous open operation", &event);
                ret = -EACCES;
            }
            break;
            
        case ACTION_LOG_ONLY:
            log_security_event("Suspicious open operation detected", &event);
            ret = orig_sys_openat(dfd, filename, flags, mode);
            break;
            
        default:
            ret = orig_sys_openat(dfd, filename, flags, mode);
            break;
    }
    
    mutex_unlock(&protection_mutex);
    
    kfree(kernel_filename);
    return ret;
}

/**
 * 音量键事件处理器 (简化版本，实际需要根据具体输入子系统实现)
 */
static int volume_key_handler(struct notifier_block *nb, unsigned long action, void *data)
{
    // 这里需要根据具体的输入子系统API实现
    // 由于不同Android版本和设备的输入处理方式不同，这里提供一个框架
    
    // 检查是否为音量键事件
    // if (是音量+键按下) {
    //     atomic_set(&user_input_state.volume_up_pressed, 1);
    //     complete(&user_input_state.input_completion);
    // } else if (是音量-键按下) {
    //     atomic_set(&user_input_state.volume_down_pressed, 1);
    //     complete(&user_input_state.input_completion);
    // }
    
    return NOTIFY_OK;
}

static struct notifier_block volume_key_notifier = {
    .notifier_call = volume_key_handler,
};

/**
 * Proc文件系统接口 - 统计信息
 */
static int stats_proc_show(struct seq_file *m, void *v)
{
    seq_printf(m, "MalwareProtector Statistics:\n");
    seq_printf(m, "Total Operations: %d\n", atomic_read(&stats.total_operations));
    seq_printf(m, "Blocked Operations: %d\n", atomic_read(&stats.blocked_operations));
    seq_printf(m, "User Confirmed: %d\n", atomic_read(&stats.user_confirmed));
    seq_printf(m, "Auto Denied: %d\n", atomic_read(&stats.auto_denied));
    seq_printf(m, "Sensitive Partition Access: %d\n", atomic_read(&stats.sensitive_partition_access));
    seq_printf(m, "Protection Enabled: %s\n", protection_enabled ? "Yes" : "No");
    return 0;
}

static int stats_proc_open(struct inode *inode, struct file *file)
{
    return single_open(file, stats_proc_show, NULL);
}

static const struct proc_ops stats_proc_ops = {
    .proc_open = stats_proc_open,
    .proc_read = seq_read,
    .proc_lseek = seq_lseek,
    .proc_release = single_release,
};

/**
 * 模块初始化
 */
static int __init malware_protector_init(void)
{
    int ret = 0;
    
    printk(KERN_INFO "[%s] Initializing MalwareProtector KPM v%s\n", MODULE_NAME, MODULE_VERSION);
    
    // 初始化统计信息
    atomic_set(&stats.total_operations, 0);
    atomic_set(&stats.blocked_operations, 0);
    atomic_set(&stats.user_confirmed, 0);
    atomic_set(&stats.auto_denied, 0);
    atomic_set(&stats.sensitive_partition_access, 0);
    
    // 初始化互斥锁
    mutex_init(&protection_mutex);
    
    // 创建proc目录
    proc_dir = proc_mkdir(MODULE_NAME, NULL);
    if (!proc_dir) {
        printk(KERN_ERR "[%s] Failed to create proc directory\n", MODULE_NAME);
        return -ENOMEM;
    }
    
    // 创建统计信息proc文件
    if (!proc_create("stats", 0444, proc_dir, &stats_proc_ops)) {
        printk(KERN_ERR "[%s] Failed to create stats proc file\n", MODULE_NAME);
        proc_remove(proc_dir);
        return -ENOMEM;
    }
    
    // Hook系统调用 (需要根据实际KPM框架API调整)
    // 这里使用假设的KPM API
    /*
    ret = kp_hook_syscall(__NR_write, hooked_sys_write, (void**)&orig_sys_write);
    if (ret) {
        printk(KERN_ERR "[%s] Failed to hook sys_write\n", MODULE_NAME);
        goto cleanup;
    }
    
    ret = kp_hook_syscall(__NR_execve, hooked_sys_execve, (void**)&orig_sys_execve);
    if (ret) {
        printk(KERN_ERR "[%s] Failed to hook sys_execve\n", MODULE_NAME);
        goto cleanup;
    }
    
    ret = kp_hook_syscall(__NR_openat, hooked_sys_openat, (void**)&orig_sys_openat);
    if (ret) {
        printk(KERN_ERR "[%s] Failed to hook sys_openat\n", MODULE_NAME);
        goto cleanup;
    }
    */
    
    // 注册音量键事件处理器 (需要根据具体输入子系统实现)
    // register_keyboard_notifier(&volume_key_notifier);
    
    printk(KERN_INFO "[%s] MalwareProtector KPM loaded successfully\n", MODULE_NAME);
    return 0;
    
cleanup:
    if (proc_dir) {
        proc_remove(proc_dir);
    }
    return ret;
}

/**
 * 模块清理
 */
static void __exit malware_protector_exit(void)
{
    printk(KERN_INFO "[%s] Unloading MalwareProtector KPM\n", MODULE_NAME);
    
    // 取消Hook (需要根据实际KPM框架API调整)
    /*
    if (orig_sys_write)
        kp_unhook_syscall(__NR_write);
    if (orig_sys_execve)
        kp_unhook_syscall(__NR_execve);
    if (orig_sys_openat)
        kp_unhook_syscall(__NR_openat);
    */
    
    // 注销音量键事件处理器
    // unregister_keyboard_notifier(&volume_key_notifier);
    
    // 清理proc文件系统
    if (proc_dir) {
        proc_remove(proc_dir);
    }
    
    printk(KERN_INFO "[%s] MalwareProtector KPM unloaded\n", MODULE_NAME);
}

module_init(malware_protector_init);
module_exit(malware_protector_exit);

// KPM模块导出符号 (需要根据实际KPM框架调整)
// KPM_INIT(malware_protector_init);
// KPM_EXIT(malware_protector_exit);